# Autohinting

*Or, how to smash a [glyph](https://rsheeter.github.io/font101/#glyph-ids-and-the-cmap-table)
into the pixel grid without any help from the font designer.*

[Hinting](https://en.wikipedia.org/wiki/Font_hinting) is the process of
generating information (aka "hints") for a font that defines how glyph outlines
should be adjusted at various sizes so that the edges better align with the
pixel grid when rasterized. This improves contrast and readability at small sizes. 

> See [The Raster Tragedy](http://rastertragedy.com/) for a deeper dive into the
process of rendering high quality text.

Manual hinting is done explicitly by the font developer, typically through the
use of graphical tools (such as [vtt](https://learn.microsoft.com/en-us/typography/tools/vtt/) or
[Glyphs](https://glyphsapp.com/learn/hinting-manual-truetype-hinting)) or
writing TrueType instructions directly.

*Auto*hinting is done by software, using a set of heuristics to determine how
outlines should be adjusted. This can be done ahead of time
(see [ttfautohint](https://freetype.org/ttfautohint/)) or just in time as glyph
outlines are requested from the font. This document will focus on the latter.
Of particular interest to Google: Android makes heavy use of runtime autohinting but this is becoming increasingly
unnecessary as the prevalence of high resolution screens grows.

> Note: the techniques discussed here are implemented in 
[skrifa](https://github.com/googlefonts/fontations/tree/2c9212d99184498327aa44b2069f8183025f5fa9/skrifa/src/outline/autohint)
but are based heavily on the original work done by David Turner, Werner
Lemberg and others in the FreeType
[autofit](https://gitlab.freedesktop.org/freetype/freetype/-/tree/f92c96550ad763639158587974cf11067ace743d/src/autofit)
module. See [Real-Time Grid Fitting of Typographic Outlines](https://www.tug.org/TUGboat/tb24-3/lemberg.pdf) for more insight into the FreeType design.

> Secondary note: this is a tour of the autohinting process. The actual
implementation is fairly complex and not amenable to a full description here.
Links have been provided to the relevant pieces of code so that the
interested reader can follow along. Improvements to this document are
welcome!

Let's talk autohinting:

* [The stylish blues](#the-stylish-blues)- style classification and metrics
computation
* [The importance of connection](#the-importance-of-connection)- topological
analysis of outlines
* [Time for a change](#time-for-a-change)- making adjustments to an outline

## The stylish blues

Before we can start mucking about with outlines, we need to gather some
information from the font to determine exactly *how* the outlines should be
adjusted.

This information falls into two categories:

### Style classification ([src](https://github.com/googlefonts/fontations/blob/6eff17a15ca0caaea27eb130fa959d529d58625b/skrifa/src/outline/autohint/style.rs))

Styles are effectively groups of glyphs that should be hinted in the same way
with the same set of metrics (see the next section). These groups are broadly
defined by Unicode script but may be further divided by specific OpenType
features when the glyphs produced by those features would have different sizes
and/or positions (e.g. subscripts, superscripts, small capitals).

Style classification proceeds in three phases:
1. Enumerate the character to glyph id mapping table and assign styles
 roughly based on Unicode script. For example, the glyph id associated
 with the character "A" would be assigned the "Latin default" style.
2. Process the layout substitution tables for known script/feature combinations
 and assign the appropriate styles to glyphs that are *output* from those
 substitutions. For example, any glyph id that is generated by the `smcp`
 feature under the `latn` script would be assigned the "Latin small caps"
 style.
 3. Process the layout substitution tables again, for each script, and assign
 the default style for that script to any remaining unassigned glyph ids that
 appear as outputs. This captures things like ligatures.

This process is done for all glyphs at once when the autohinter state is
initialized. The structure of a font file (lacking efficient mappings from
glyph id to character or to layout feature) makes it cost prohibitive to do
style classification for a single glyph. 

### Style metrics ([src](https://github.com/googlefonts/fontations/tree/6eff17a15ca0caaea27eb130fa959d529d58625b/skrifa/src/outline/autohint/metrics))

Once we've classified all of our glyphs, the next step is to compute some
metrics for each of the relevant styles in our glyph set. The purpose of these
metrics is to ensure that glyph outlines of the same style are adjusted in a
consistent manner to avoid jarring visual differences when the outlines are
rendered together.

Metrics consist of two related concepts:

#### Alignment (aka "blue") zones ([src](https://github.com/googlefonts/fontations/blob/6eff17a15ca0caaea27eb130fa959d529d58625b/skrifa/src/outline/autohint/metrics/blues.rs))

These define the extrema, or positions of outside edges for significant
regions such as the top, bottom or x-height of a set of glyphs. Each style
contains a list of candidate characters that are used to compute the
positions of each alignment zone. For example, the maximum y value of the
all points in the "T" glyph might be used to compute the top alignment
zone while the minimum y value of all points in the "y" glyph could be
used to compute the position of a bottom zone. Note that these are called
zones but are computed as a single positions-- like most things in
autohinting, these positions will be expanded into a region by a heuristic
distance later when we determine which edges are "captured" by the
blue zones.

Overall, alignment zones ensure consistent _placement_ of features when
adjusting outlines.

#### Standard stem widths ([src](https://github.com/googlefonts/fontations/blob/6eff17a15ca0caaea27eb130fa959d529d58625b/skrifa/src/outline/autohint/metrics/widths.rs))

These define the distance between two adjacent edges that make up a stem. 
Think the width of the stroke of a lowercase "o". Like alignment zones,
each style contains a list of candidate characters that are used to compute
the set of standard widths. The outlines for each of the candidate characters
is processed to determine the set of relevant edges (see "edge detection" below)
and the sorted set of distances between adjacent edges is saved for later use.

Overall, stem widths ensure consistent _visual weight_ of features when
adjusting outlines.

#### Scaling and grid-fitting metrics ([src](https://github.com/googlefonts/fontations/blob/bb9fd93028bbadb21b18ce11fecf69a5b0eb0216/skrifa/src/outline/autohint/metrics/scale.rs))

Both alignment zones and stem widths are scaled to the requested font size
and grid-fitted before use by the subsequent hinting phases.

### Precomputation

It might make sense to precompute this information and store it in the font to
avoid the cost of initialization. For non-variable fonts, we can compute both
styles and metrics. For variable fonts, we can precompute styles but must defer
metrics to runtime since those are dependent on the position in variation space.

## The importance of connection

Glyph outlines are defined by a set of contours with each contour containing a
sequence of points. In order to make any reasonable adjustments, we must first
identify the topological features of an outline.

> Note: Topological feature detection is _separable_ in that it can be done
independently for each axis. We take advantage of that to both reduce computational
complexity and allow for "light" hinting where we only analyze and modify an
outline in the vertical direction.

This proceeds in three phases:

### Initial point analysis ([src](https://github.com/googlefonts/fontations/blob/6eff17a15ca0caaea27eb130fa959d529d58625b/skrifa/src/outline/autohint/outline.rs#L161))

The purpose of this pass, roughly, is to classify the incoming and outgoing
directions of each point. These directions are determined by computing the
vectors between each point and its neighbors and then quantizing them into one
of left, right, up or down.

Points that don't have dominant incoming or outgoing directions or that are too
near to their neighbors are tagged (with a weak interpolation flag) for special
processing later.

### Segment detection ([src](https://github.com/googlefonts/fontations/blob/6eff17a15ca0caaea27eb130fa959d529d58625b/skrifa/src/outline/autohint/topo/segments.rs))

A segment is a contiguous sequence of points (in a single contour) that are
aligned in the same direction. These are computed by walking the point list of
each contour and accumulating runs of points where the outgoing direction
is the same _and_ aligns with the current axis. For example, if we are building
segments for the vertical axis, points with an outgoing direction of either
"left" or "right" would be considered and all points assigned to a single segment
would have the same direction.

Each segment is given a position along the desired axis which is computed as
the midpoint of the minimum and maximum positions of all points that compose
the segment.

After segments are computed, they are linked to form stems. A stem is simply
a pair of segments that lie within a heuristic distance threshold and have
the opposite direction.

### Edge detection ([src](https://github.com/googlefonts/fontations/blob/6eff17a15ca0caaea27eb130fa959d529d58625b/skrifa/src/outline/autohint/topo/edges.rs))

An edge is a collection of segments that share the same position (within a
heuristic threshold) on a given axis. These are computed as might be expected:
for each segment, we search for an existing edge whose position is within the
distance threshold. If one isn't found, a new edge is created.

The computed edge list is sorted by position: left to right for horizontal
hinting and either top to bottom or bottom to top for vertical hinting,
depending on the script assigned to the glyph-- most scripts hint from the
baseline up but some scripts with a "hanging baseline" (such as the Indic
group) produce better results when hinted top down.

After edges are computed, the links between segments that were computed in
the previous pass are propagated to the edges to form edge stems.

Finally, we assign a blue (alignment) zone to each edge that falls within
the region for that zone.

### A simple visual example

Consider the following lovely ASCII representation of a lowercase "t" where
each point is signified by a letter (the extraneous G and J points added
just to demonstrate segments with more than two points):
<pre>
                 A --- B
                 |     |
            M -- N     C -- D
            |               |
            L -- K     F -- E
                 |     |
                 J     G
                 |     |
                 I --- H
</pre>

Assuming hinting in the horizontal direction (left to right), we would compute
the following topological features:

* Segments (in outline order which is clockwise in this case):
  * BC
  * DE
  * FGH
  * IJK
  * LM
  * NA

* Segment links (stems)
  * NA <-> BC
  * IJK <-> FGH

> Note that DE and LM _do not_ form a link because the distance between them
  surpasses the threshold.

* Edges
  * BC, FGH
  * DE
  * IJK, NA
  * LM

> Note that edges can be formed from non-contiguous segments.

* Edge links (stems)
  * BC, FGH <-> IJK, NA

## Time for a change

Once we've computed the topological features of our outline, we can start
making adjustments. In general, grid-fitting is applied directly to our
computed _edges_ and then those changes are propagated to the outline
_points_.

### Hinting edges ([src](https://github.com/googlefonts/fontations/blob/b283d608f7beca834c7d56cb649c79ba40c12411/skrifa/src/outline/autohint/hint/edges.rs))

Edge hinting is performed in three passes:

1. Edge pairs that have been assigned a blue zone are handled first. These
   edges are simply snapped to the grid-fitted position of their associated
   blue zone.
2. Stem edges (paired edges that have not been captured by a blue zone) are
   handled next. These are snapped directly to the grid without guidance from an
   alignment zone. The hinter tries to maintain a minimal distance from already
   hinted edges to avoid overlaps.
3. Remaining edges (single point edges and serifs) are handled last. These don't
   form stems so are just fitted independently.

The edges processed by the first two passes are always composed of pairs. In these
cases, the first edge is snapped to either an alignment zone or the closest pixel.
The position of the second edge is computed by mapping the distance between the two
edges to the closest matching "standard stem width" from the set described in the
metrics section above.

### Hinting points ([src](https://github.com/googlefonts/fontations/blob/main/skrifa/src/outline/autohint/hint/outline.rs))

With grid-fitted edges available, the final step is to apply these adjustments to the
points of the original outline.

Points are adjusted in three groups:

1. Points that directly contributed to edge formation are adjusted first. We
   iterate through the segments that make up each edge and then through the
   points that make up each segment and apply the adjustment. For "strong"
   hinting, all points are snapped directly to the position of the edge. In
   lighter hinting modes, points are shifted by the difference between the
   original and grid-fitted edge position.
2. Points that weren't touched in the previous pass and are also not flagged
   for weak interpolation are adjusted next. For these points, we find the
   nearest enclosing edges and perform a linear interpolation based on the
   adjustments made to those two edges.
3. Finally, all remaining points are adjusted using the same procedure
   as IUP (interpolate untouched points) for variations and TrueType hinting:
   we detect contiguous sequences of unmodified points and interpolate them
   based on the adjustments made to the points on the boundary.

### Grid-fitting complete

And with that, we have a nicely hinted outline! Simple.
